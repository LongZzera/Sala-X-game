<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SALA X - Sobreviv√™ncia Escolar (PC)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'VT323', monospace; user-select: none; }
        
        /* HUD e UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: transparent; border: 2px solid lime; border-radius: 50%;
            transform: translate(-50%, -50%); z-index: 10;
        }

        .hud-panel {
            position: absolute; padding: 10px; background: rgba(0, 0, 0, 0.7); 
            border: 2px solid white; color: white; font-size: 24px;
        }

        #stats-hud { bottom: 20px; left: 20px; width: 250px; }
        #temp-bar-bg { width: 100%; height: 20px; background: #333; margin-top: 5px; border: 1px solid #fff; }
        #temp-bar-fill { height: 100%; width: 50%; background: orange; transition: width 0.2s, background 0.2s; }
        
        #day-hud { top: 20px; right: 20px; font-size: 40px; color: lime; text-align: right; }

        #message-area {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, 0);
            color: yellow; font-size: 32px; text-shadow: 2px 2px #000; text-align: center;
            display: none;
        }

        #monitor-warning {
            position: absolute; top: 10%; left: 50%; transform: translate(-50%, 0);
            color: red; font-size: 48px; font-weight: bold; animation: blink 0.5s infinite;
            display: none; text-transform: uppercase;
        }

        /* Telas de Bloqueio (Interativas) */
        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none; flex-direction: column;
            align-items: center; justify-content: center; color: white; z-index: 20;
            pointer-events: auto;
        }

        #start-screen { display: flex; background: #111; }
        h1 { font-size: 80px; margin: 0; color: lime; text-shadow: 4px 4px #000; }
        button {
            background: #333; color: white; border: 2px solid white; 
            padding: 15px 30px; font-size: 24px; cursor: pointer; font-family: 'VT323', monospace;
            margin-top: 20px;
        }
        button:hover { background: #555; }
        
        .minigame-options { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; justify-content: center; }
        .hint-btn { background: #0044aa; font-size: 18px; padding: 10px; width: 120px; }

        #math-screen input { font-size: 30px; padding: 5px; width: 100px; text-align: center; }
        
        #door-pad { 
            background: #444; padding: 20px; border: 4px solid #888; display: grid; 
            grid-template-columns: repeat(3, 1fr); gap: 10px; 
        }
        .pad-btn { width: 50px; height: 50px; font-size: 24px; cursor: pointer; background: #222; color: #fff; border: 1px solid #fff; }
        #door-display { grid-column: span 3; background: #000; color: lime; font-size: 30px; text-align: center; padding: 5px; margin-bottom: 10px; }

        /* Memory Game Styles */
        #memory-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px;
        }
        .memory-card {
            width: 80px; height: 80px; background: #333; border: 2px solid #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 40px; cursor: pointer; color: transparent;
        }
        .memory-card.flipped { background: #fff; color: #000; }
        .memory-card.matched { background: lime; color: #000; border-color: lime; }

        /* Canvas Styles for Snake/Pacman */
        canvas { background: #000; border: 4px solid #fff; margin-bottom: 10px; }

        @keyframes blink { 0% {opacity: 1;} 50% {opacity: 0;} 100% {opacity: 1;} }
    </style>
</head>
<body>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <div id="crosshair"></div>
        
        <div id="monitor-warning">‚ö† HELITON SE APROXIMA! ‚ö†</div>
        <div id="message-area">Mensagem do Sistema</div>
        
        <div id="day-hud" class="hud-panel">DIA <span id="day-val">1</span></div>

        <div id="stats-hud" class="hud-panel">
            <div>VIDAS: <span id="lives-display" style="color:red">‚ù§‚ù§‚ù§</span></div>
            <div style="margin-top: 10px;">TEMPERATURA: <span id="temp-val">50%</span></div>
            <div id="temp-bar-bg"><div id="temp-bar-fill"></div></div>
            <div style="margin-top: 10px; font-size: 18px; color: #aaa;">
                [W,A,S,D] Mover <br>
                [I] ou [Q] Soltar/Pegar Blusa <br>
                [E] Interagir/Esconder
            </div>
            <div style="margin-top: 5px; color: yellow;" id="code-collection">C√≥digos: _ _ _ _</div>
        </div>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay-screen">
        <h1>SALA X</h1>
        <p>Regras: Sobreviva 7 DIAS. Fuja do Corvo Darci.</p>
        <p>O monitor Heliton fiscaliza uniformes.</p>
        <button id="btn-start">COME√áAR DIA 1</button>
    </div>

    <!-- MATH SCREEN -->
    <div id="math-screen" class="overlay-screen">
        <h2 style="color: yellow">RESOLVA PARA PEGAR O C√ìDIGO!</h2>
        <div id="math-problem" style="font-size: 40px; margin: 20px;">2 + 2 = ?</div>
        <div id="hint-text" style="color: cyan; margin-bottom: 10px; font-size: 24px; min-height: 30px;"></div>
        <input type="number" id="math-input" autofocus>
        <button id="btn-submit-math">RESPONDER</button>
        
        <div id="minigame-selection" class="minigame-options" style="display:none;">
            <div style="width:100%; text-align:center; color:#aaa;">PRECISA DE AJUDA? JOGUE:</div>
            <button class="hint-btn" onclick="initMemoryGame()">MEM√ìRIA</button>
            <button class="hint-btn" onclick="initPacmanGame()">PAC-MAN</button>
            <button class="hint-btn" onclick="initSnakeGame()">COBRINHA</button>
        </div>
        <div style="margin-top:20px; color: #aaa; font-size: 18px;">Se errar, o caderno fecha.</div>
    </div>

    <!-- MEMORY GAME SCREEN -->
    <div id="memory-screen" class="overlay-screen">
        <h2 style="color: cyan">MEM√ìRIA: ACHE OS PARES</h2>
        <div id="memory-grid">
            <!-- Cards generated by JS -->
        </div>
        <p>Complete para ver a resposta da conta.</p>
        <button onclick="closeMinigame()">CANCELAR</button>
    </div>

    <!-- PACMAN SCREEN -->
    <div id="pacman-screen" class="overlay-screen">
        <h2 style="color: yellow">PAC-MAN</h2>
        <p>Coma todas as p√≠lulas. Fuja do fantasma!</p>
        <canvas id="pacman-canvas" width="300" height="300"></canvas>
        <button onclick="closeMinigame()">CANCELAR</button>
    </div>

    <!-- SNAKE SCREEN -->
    <div id="snake-screen" class="overlay-screen">
        <h2 style="color: lime">COBRINHA</h2>
        <p>Coma 5 ma√ß√£s para ganhar.</p>
        <canvas id="snake-canvas" width="300" height="300"></canvas>
        <button onclick="closeMinigame()">CANCELAR</button>
    </div>

    <!-- DOOR SCREEN -->
    <div id="door-screen" class="overlay-screen">
        <h2>PAINEL DE SEGURAN√áA</h2>
        <div id="door-pad">
            <div id="door-display">----</div>
            <!-- Bot√µes gerados via JS -->
        </div>
        <button onclick="closeDoorScreen()">SAIR</button>
    </div>

    <!-- GAME OVER / WIN -->
    <div id="end-screen" class="overlay-screen">
        <h1 id="end-title">GAME OVER</h1>
        <p id="end-reason" style="font-size: 30px;"></p>
        <button id="btn-restart" onclick="location.reload()">TENTAR NOVAMENTE</button>
        <button id="btn-next-day" style="display:none">PR√ìXIMO DIA</button>
    </div>

    <!-- THREE.JS IMPORTS -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURA√á√ïES GERAIS ---
        const GAME_CONFIG = {
            walkSpeed: 15.0, 
            tempRateUp: 1.5,    
            tempRateDown: 0.8,  
            stalkerSpeed: 4.0, 
            monitorCycle: 30,     
            stalkerCycle: 15,   
            stalkerDuration: 8 
        };

        const mapGrid = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,3,0,0,1,0,0,0,0,0,1,0,0,2,1], 
            [1,2,0,0,0,0,0,0,0,0,0,0,0,3,1], 
            [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,1,0,1,1,0,0,0,0,0,1,1,0,1,1], 
            [1,0,0,0,1,0,2,0,2,0,1,0,0,0,1], 
            [1,0,2,0,0,0,0,0,0,0,0,0,2,0,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,1,0,1,1,0,0,0,0,0,1,1,0,1,1],
            [1,3,0,0,1,0,0,0,0,0,1,0,0,0,1], 
            [1,0,0,2,0,0,0,0,0,0,0,2,0,0,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,0,3,1], 
            [1,1,1,1,1,1,0,0,0,1,1,1,1,1,1], 
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,2,0,0,0,0,0,0,0,0,0,0,0,2,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,9,1,1,1,1,1,1,1]  
        ];
        const UNIT_SIZE = 5;

        // --- ESTADO DO JOGO ---
        let gameState = {
            day: 1,
            lives: 3,
            temp: 50,           
            hasJacket: true,
            codesFound: [],     
            finalCode: [],      
            currentMathAnswer: 0,
            isPaused: false,
            isHiding: false,
            inDoor: false,
            gameOver: false,
            activeNotebook: null,
            activeMinigame: null
        };

        let timers = {
            monitor: 0,
            stalker: 0,
            stalkerActiveTimer: 0
        };

        // --- VARI√ÅVEIS THREE.JS ---
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Entidades
        let jacketObj = null; 
        let crowGroup = null; 
        let crowWings = []; 
        let monitorGroup = null; 
        let monitorLimbs = []; 
        let lockers = []; 
        let walls = [];   
        let notebooks = []; 
        let exitDoor = null;

        // --- VARI√ÅVEIS MINIGAMES ---
        let snakeGame = {
            snake: [], dir: {x:1, y:0}, food: {x:0, y:0}, score: 0, interval: null
        };
        let pacmanGame = {
            pos: {x:1, y:1}, dir: {x:0, y:0}, nextDir: {x:0, y:0},
            ghost: {x:8, y:8}, ghostDir: {x:0, y:0}, ghostTimer: 0,
            grid: [], score: 0, totalDots: 0, interval: null
        };

        // --- ASSETS PROCEDURAIS ---
        function createTexture(color, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0,0,128,128);
            if(text) {
                ctx.fillStyle = 'white';
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 64, 64);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            wall: createTexture('#444', ''),
            floor: createTexture('#222', ''),
            jacket: createTexture('#0000FF', 'üß•'),
            notebook: createTexture('#00AA00', 'üìì'),
            locker: createTexture('#553311', 'üö™'),
            door: createTexture('#888', 'EXIT')
        };

        // --- INICIALIZA√á√ÉO ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 0, 30);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6;

            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);
            const pointLight = new THREE.PointLight(0xffaa00, 1, 15);
            camera.add(pointLight);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            
            // Travar mouse ao clicar no Start
            document.getElementById('btn-start').addEventListener('click', startGamePlay);
            document.getElementById('btn-next-day').addEventListener('click', nextDay);

            // Re-travar mouse ao clicar na tela se o jogo estiver rodando
            document.body.addEventListener('click', () => {
                if(!gameState.gameOver && !gameState.isPaused && !gameState.inDoor && gameState.day > 0) {
                    controls.lock();
                }
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 3);

            buildMap();
            setupEntities();
            
            // Expor fun√ß√µes para o HTML
            window.initMemoryGame = initMemoryGame;
            window.initPacmanGame = initPacmanGame;
            window.initSnakeGame = initSnakeGame;
            window.closeMinigame = closeMinigame;
            window.closeDoorScreen = closeDoorScreen;
        }

        function startGamePlay() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('end-screen').style.display = 'none';
            controls.lock();
            resetLevel();
        }

        function nextDay() {
            gameState.day++;
            if(gameState.day > 7) {
                triggerWinGame();
                return;
            }
            startGamePlay();
        }

        function resetLevel() {
            gameState.temp = 50;
            gameState.codesFound = [];
            gameState.isPaused = false;
            gameState.isHiding = false;
            gameState.inDoor = false;
            gameState.gameOver = false;
            
            timers.monitor = 0;
            timers.stalker = 0;
            timers.stalkerActiveTimer = 0;

            generateCode();
            
            notebooks.forEach(nb => {
                nb.visible = true;
                nb.userData.collected = false;
            });

            controls.getObject().position.set(0, 1.6, 0); 
            controls.getObject().rotation.set(0,0,0);
            
            crowGroup.position.set(0, -50, 0);
            monitorGroup.position.set(0, -50, 0);

            gameState.hasJacket = true;
            if(jacketObj) jacketObj.visible = false;

            updateHUD();
            document.getElementById('day-val').innerText = gameState.day;
            showMessage(`DIA ${gameState.day} INICIADO`);
        }

        function generateCode() {
            gameState.finalCode = [];
            for(let i=0; i<4; i++) gameState.finalCode.push(Math.floor(Math.random()*10));
            console.log("C√≥digo Secreto:", gameState.finalCode.join(''));
            updateCodeDisplay();
        }

        function buildMap() {
            const floorGeo = new THREE.PlaneGeometry(150, 150);
            const floorMat = new THREE.MeshStandardMaterial({ map: textures.floor });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = - Math.PI / 2;
            scene.add(floor);

            const boxGeo = new THREE.BoxGeometry(UNIT_SIZE, UNIT_SIZE, UNIT_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ map: textures.wall });
            const lockerMat = new THREE.MeshStandardMaterial({ map: textures.locker });

            for (let z = 0; z < mapGrid.length; z++) {
                for (let x = 0; x < mapGrid[z].length; x++) {
                    const type = mapGrid[z][x];
                    const posX = (x * UNIT_SIZE) - (mapGrid[0].length * UNIT_SIZE) / 2;
                    const posZ = (z * UNIT_SIZE) - (mapGrid.length * UNIT_SIZE) / 2;

                    if (type === 1) {
                        const wall = new THREE.Mesh(boxGeo, wallMat);
                        wall.position.set(posX, UNIT_SIZE/2, posZ);
                        scene.add(wall);
                        walls.push(new THREE.Box3().setFromObject(wall));
                    } else if (type === 2) {
                        const locker = new THREE.Mesh(boxGeo, lockerMat);
                        locker.scale.set(0.8, 1, 0.8);
                        locker.position.set(posX, UNIT_SIZE/2, posZ);
                        locker.userData = { type: 'locker' };
                        scene.add(locker);
                        walls.push(new THREE.Box3().setFromObject(locker)); 
                        lockers.push(locker);
                    } else if (type === 9) {
                        const doorGeo = new THREE.PlaneGeometry(UNIT_SIZE, UNIT_SIZE);
                        const door = new THREE.Mesh(doorGeo, new THREE.MeshBasicMaterial({map: textures.door}));
                        door.position.set(posX, UNIT_SIZE/2, posZ - 0.1);
                        if(z === mapGrid.length -1) door.rotation.y = Math.PI;
                        door.userData = { type: 'door' };
                        scene.add(door);
                        exitDoor = door;
                        walls.push(new THREE.Box3().setFromObject(door));
                    } else if (type === 3) {
                        const mat = new THREE.SpriteMaterial({ map: textures.notebook });
                        const notebook = new THREE.Sprite(mat);
                        notebook.scale.set(1.5, 1.5, 1);
                        notebook.position.set(posX, 1.5, posZ);
                        notebook.userData = { type: 'notebook', collected: false };
                        scene.add(notebook);
                        notebooks.push(notebook);
                    }
                }
            }
        }

        function createCrowModel() {
            const group = new THREE.Group();
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const yellowMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            
            const bodyGeo = new THREE.CapsuleGeometry(0.3, 0.6, 4, 8);
            const body = new THREE.Mesh(bodyGeo, blackMat);
            body.rotation.x = Math.PI / 2; 
            group.add(body);

            const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
            const head = new THREE.Mesh(headGeo, blackMat);
            head.position.set(0, 0.2, 0.5);
            group.add(head);

            const beakGeo = new THREE.ConeGeometry(0.08, 0.4, 8);
            const beak = new THREE.Mesh(beakGeo, yellowMat);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 0.15, 0.8);
            group.add(beak);

            const wingGeo = new THREE.BoxGeometry(1.2, 0.05, 0.6);
            const wingLGroup = new THREE.Group();
            const wingL = new THREE.Mesh(wingGeo, blackMat);
            wingL.position.x = 0.6; 
            wingLGroup.add(wingL);
            wingLGroup.position.set(0.2, 0.1, 0);
            group.add(wingLGroup);
            crowWings.push(wingLGroup);

            const wingRGroup = new THREE.Group();
            const wingR = new THREE.Mesh(wingGeo, blackMat);
            wingR.position.x = -0.6; 
            wingRGroup.add(wingR);
            wingRGroup.position.set(-0.2, 0.1, 0);
            group.add(wingRGroup);
            crowWings.push(wingRGroup);
            return group;
        }

        function createMonitorModel() {
            const group = new THREE.Group();
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa }); 
            const shirtMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); 
            const pantsMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); 
            const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 1.7;
            group.add(head);

            const eyeGeo = new THREE.SphereGeometry(0.03, 8, 8);
            const eyeL = new THREE.Mesh(eyeGeo, blackMat);
            eyeL.position.set(0.1, 1.75, 0.22);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, blackMat);
            eyeR.position.set(-0.1, 1.75, 0.22);
            group.add(eyeR);

            const noseGeo = new THREE.ConeGeometry(0.03, 0.1, 8);
            const nose = new THREE.Mesh(noseGeo, skinMat);
            nose.position.set(0, 1.7, 0.25);
            nose.rotation.x = Math.PI / 2;
            group.add(nose);

            const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.3);
            const torso = new THREE.Mesh(torsoGeo, shirtMat);
            torso.position.y = 1.25;
            group.add(torso);

            const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.7);
            const armLGroup = new THREE.Group();
            armLGroup.position.set(0.35, 1.55, 0);
            const armL = new THREE.Mesh(armGeo, shirtMat);
            armL.position.y = -0.35;
            armLGroup.add(armL);
            group.add(armLGroup);
            monitorLimbs.push(armLGroup);

            const armRGroup = new THREE.Group();
            armRGroup.position.set(-0.35, 1.55, 0);
            const armR = new THREE.Mesh(armGeo, shirtMat);
            armR.position.y = -0.35;
            armRGroup.add(armR);
            group.add(armRGroup);
            monitorLimbs.push(armRGroup);

            const legGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.9);
            const legLGroup = new THREE.Group();
            legLGroup.position.set(0.15, 0.9, 0);
            const legL = new THREE.Mesh(legGeo, pantsMat);
            legL.position.y = -0.45;
            legLGroup.add(legL);
            group.add(legLGroup);
            monitorLimbs.push(legLGroup);

            const legRGroup = new THREE.Group();
            legRGroup.position.set(-0.15, 0.9, 0);
            const legR = new THREE.Mesh(legGeo, pantsMat);
            legR.position.y = -0.45;
            legRGroup.add(legR);
            group.add(legRGroup);
            monitorLimbs.push(legRGroup);
            return group;
        }

        function setupEntities() {
            crowGroup = createCrowModel();
            crowGroup.position.set(0, -50, 0); 
            crowGroup.scale.set(1.5, 1.5, 1.5);
            scene.add(crowGroup);

            monitorGroup = createMonitorModel();
            monitorGroup.position.set(0, -50, 0);
            scene.add(monitorGroup);
        }

        // --- CONTROLES ---
        function onKeyDown(event) {
            // Minigames Input
            if (gameState.activeMinigame === 'snake') {
                if(event.code === 'ArrowUp' && snakeGame.dir.y !== 1) snakeGame.dir = {x:0, y:-1};
                if(event.code === 'ArrowDown' && snakeGame.dir.y !== -1) snakeGame.dir = {x:0, y:1};
                if(event.code === 'ArrowLeft' && snakeGame.dir.x !== 1) snakeGame.dir = {x:-1, y:0};
                if(event.code === 'ArrowRight' && snakeGame.dir.x !== -1) snakeGame.dir = {x:1, y:0};
                return;
            }
            if (gameState.activeMinigame === 'pacman') {
                if(event.code === 'ArrowUp') pacmanGame.nextDir = {x:0, y:-1};
                if(event.code === 'ArrowDown') pacmanGame.nextDir = {x:0, y:1};
                if(event.code === 'ArrowLeft') pacmanGame.nextDir = {x:-1, y:0};
                if(event.code === 'ArrowRight') pacmanGame.nextDir = {x:1, y:0};
                return;
            }

            // Main Game Input
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'KeyI': case 'KeyQ': dropJacket(); break;
                case 'KeyE': interact(); break;
            }
        }
        function onKeyUp(event) {
            if (gameState.activeMinigame) return;
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }

        // --- L√ìGICA DE INTERA√á√ÉO ---
        function interact() {
            if (gameState.gameOver || gameState.isPaused) return;

            if (gameState.isHiding) {
                exitHiding();
                return;
            }

            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            raycaster.set(camera.position, camDir);
            raycaster.camera = camera; 

            if (!gameState.hasJacket && jacketObj) {
                const intersects = raycaster.intersectObject(jacketObj);
                if (intersects.length > 0 && intersects[0].distance < 3.0) {
                    pickUpJacket();
                    return;
                }
            }

            const activeNotebooks = notebooks.filter(n => n.visible);
            const interactables = [...lockers, exitDoor, ...activeNotebooks];
            const intersects = raycaster.intersectObjects(interactables);
            
            if (intersects.length > 0 && intersects[0].distance < 3.0) {
                const target = intersects[0].object;
                if (target.userData.type === 'locker') {
                    enterHiding(target.position);
                } else if (target.userData.type === 'door') {
                    openDoorPanel();
                } else if (target.userData.type === 'notebook') {
                    gameState.activeNotebook = target;
                    triggerMathEvent();
                }
            }
        }

        function dropJacket() {
            if (!gameState.hasJacket || gameState.isHiding) return;
            gameState.hasJacket = false;
            showMessage("Voc√™ tirou a blusa.");
            if (!jacketObj) {
                const geo = new THREE.BoxGeometry(1, 0.2, 1);
                const mat = new THREE.MeshBasicMaterial({ map: textures.jacket });
                jacketObj = new THREE.Mesh(geo, mat);
                jacketObj.userData = { type: 'jacket' };
                scene.add(jacketObj);
            }
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            jacketObj.position.copy(camera.position).add(dir.multiplyScalar(1.5));
            jacketObj.position.y = 0.2;
            jacketObj.visible = true;
            updateHUD();
        }

        function pickUpJacket() {
            gameState.hasJacket = true;
            jacketObj.visible = false;
            showMessage("Voc√™ vestiu a blusa.");
            updateHUD();
        }

        function enterHiding(pos) {
            gameState.isHiding = true;
            showMessage("Escondido... (Aperte E para sair)");
            document.getElementById('ui-layer').style.backgroundColor = 'rgba(0,0,0,0.8)';
        }

        function exitHiding() {
            gameState.isHiding = false;
            showMessage("");
            document.getElementById('ui-layer').style.backgroundColor = 'transparent';
        }

        function updateTemperature(delta) {
            if (gameState.isPaused || gameState.gameOver) return;
            let change = 0;
            if (gameState.hasJacket) {
                change = GAME_CONFIG.tempRateUp * delta; 
            } else {
                change = -GAME_CONFIG.tempRateDown * delta; 
            }
            gameState.temp += change;
            if (gameState.temp >= 100) triggerGameOver("INSOLA√á√ÉO! Voc√™ cozinhou.");
            if (gameState.temp <= 0) triggerGameOver("HIPOTERMIA! Voc√™ congelou.");
            const bar = document.getElementById('temp-bar-fill');
            const val = document.getElementById('temp-val');
            bar.style.width = gameState.temp + '%';
            val.innerText = Math.floor(gameState.temp) + '%';
            if(gameState.temp > 80) bar.style.backgroundColor = 'red';
            else if(gameState.temp < 20) bar.style.backgroundColor = 'cyan';
            else bar.style.backgroundColor = 'orange';
        }

        function updateTimers(delta) {
            if (gameState.isPaused || gameState.gameOver) return;

            timers.monitor += delta;
            const monitorWarn = document.getElementById('monitor-warning');
            const spawnTime = GAME_CONFIG.monitorCycle - 5;
            
            if (timers.monitor > spawnTime && timers.monitor < GAME_CONFIG.monitorCycle) {
                if (monitorGroup.position.y < -10) {
                     spawnMonitor();
                }
                updateMonitorLogic(delta);
                monitorWarn.style.display = 'block';
            } else {
                monitorWarn.style.display = 'none';
                if(timers.monitor < spawnTime) monitorGroup.position.y = -50;
            }

            if (timers.monitor >= GAME_CONFIG.monitorCycle) {
                triggerMonitorEvent();
                timers.monitor = 0;
                monitorGroup.position.y = -50; 
            }

            if (timers.stalkerActiveTimer > 0) {
                timers.stalkerActiveTimer -= delta;
                updateCrowLogic(delta);
                if (timers.stalkerActiveTimer <= 0) {
                    crowGroup.position.y = -50; 
                    showMessage("Darci voou para longe.");
                }
            } else {
                timers.stalker += delta;
                if (timers.stalker >= GAME_CONFIG.stalkerCycle) {
                    activateCrow();
                    timers.stalker = 0;
                }
            }
        }

        function spawnMonitor() {
             const dir = new THREE.Vector3();
             camera.getWorldDirection(dir);
             dir.y = 0; dir.normalize();
             monitorGroup.position.copy(camera.position).add(dir.multiplyScalar(15));
             monitorGroup.position.y = 0;
             monitorGroup.lookAt(camera.position);
             monitorGroup.visible = true;
        }

        function updateMonitorLogic(delta) {
            monitorGroup.lookAt(camera.position.x, 0, camera.position.z);
            const dist = monitorGroup.position.distanceTo(camera.position);
            if(dist > 2.5) {
                const dir = new THREE.Vector3().subVectors(camera.position, monitorGroup.position).normalize();
                dir.y = 0;
                monitorGroup.position.add(dir.multiplyScalar(3.0 * delta));

                const time = performance.now() * 0.01;
                monitorLimbs[0].rotation.x = Math.sin(time) * 0.5;
                monitorLimbs[1].rotation.x = -Math.sin(time) * 0.5;
                monitorLimbs[2].rotation.x = -Math.sin(time) * 0.5;
                monitorLimbs[3].rotation.x = Math.sin(time) * 0.5;
            } else {
                monitorLimbs.forEach(l => l.rotation.x = 0);
            }
        }

        function triggerMonitorEvent() {
            let msg = "";
            let safe = !gameState.hasJacket; 
            if (safe) {
                msg = "HELITON: Muito bem, uniforme correto.";
                showMessage(msg);
            } else {
                msg = "HELITON: TIRA ESSA BLUSA! (-2 Vidas)";
                showMessage(msg);
                takeDamage(2);
            }
        }

        // --- SISTEMA DE MATEM√ÅTICA ---
        function triggerMathEvent() {
            gameState.isPaused = true;
            controls.unlock();
            
            let problemText = "";
            let finalRes = 0;

            if (gameState.day <= 2) {
                const n1 = Math.floor(Math.random()*20);
                const n2 = Math.floor(Math.random()*20);
                if (Math.random() > 0.5) {
                    problemText = `${n1} + ${n2}`;
                    finalRes = n1 + n2;
                } else {
                    const max = Math.max(n1, n2);
                    const min = Math.min(n1, n2);
                    problemText = `${max} - ${min}`;
                    finalRes = max - min;
                }
            } else if (gameState.day <= 4) {
                const n1 = Math.floor(Math.random()*10);
                const n2 = Math.floor(Math.random()*10);
                const n3 = Math.floor(Math.random()*10);
                problemText = `${n1} x ${n2} + ${n3}`;
                finalRes = (n1 * n2) + n3;
            } else {
                const n1 = Math.floor(Math.random()*15);
                const n2 = Math.floor(Math.random()*15);
                const n3 = Math.floor(Math.random()*50);
                problemText = `(${n1} + ${n2}) x 2 - ${n3}`;
                finalRes = ((n1 + n2) * 2) - n3;
            }

            gameState.currentMathAnswer = finalRes;

            document.getElementById('math-problem').innerText = `${problemText} = ?`;
            document.getElementById('hint-text').innerText = ""; 
            
            const minigameDiv = document.getElementById('minigame-selection');
            if(gameState.day >= 3) {
                minigameDiv.style.display = 'flex';
            } else {
                minigameDiv.style.display = 'none';
            }

            const screen = document.getElementById('math-screen');
            screen.style.display = 'flex';
            
            const input = document.getElementById('math-input');
            input.value = '';
            input.focus();

            const btn = document.getElementById('btn-submit-math');
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.onclick = () => {
                if(parseInt(input.value) === finalRes) {
                    showMessage("CORRETO! Voc√™ achou um d√≠gito.");
                    revealCodeFragment();
                    if(gameState.activeNotebook) {
                        gameState.activeNotebook.visible = false;
                        gameState.activeNotebook = null;
                    }
                } else {
                    showMessage("ERRADO! O caderno se fechou...");
                }
                closeMathScreen();
            };
        }

        function closeMathScreen() {
            document.getElementById('math-screen').style.display = 'none';
            gameState.isPaused = false;
            if(!gameState.gameOver) controls.lock();
        }

        // --- MINIGAME SHARED ---
        function winMinigame() {
            closeMinigame();
            const hintText = document.getElementById('hint-text');
            hintText.innerText = "RESPOSTA: " + gameState.currentMathAnswer;
            showMessage("Dica Revelada!");
        }

        window.closeMinigame = function() {
            gameState.activeMinigame = null;
            if(snakeGame.interval) clearInterval(snakeGame.interval);
            if(pacmanGame.interval) clearInterval(pacmanGame.interval);
            document.getElementById('memory-screen').style.display = 'none';
            document.getElementById('pacman-screen').style.display = 'none';
            document.getElementById('snake-screen').style.display = 'none';
            document.getElementById('math-screen').style.display = 'flex';
        }

        // --- MINIGAME: SNAKE ---
        function initSnakeGame() {
            document.getElementById('math-screen').style.display = 'none';
            document.getElementById('snake-screen').style.display = 'flex';
            gameState.activeMinigame = 'snake';
            
            snakeGame.snake = [{x:7, y:7}];
            snakeGame.dir = {x:1, y:0};
            snakeGame.score = 0;
            placeSnakeFood();
            
            if(snakeGame.interval) clearInterval(snakeGame.interval);
            snakeGame.interval = setInterval(updateSnake, 150);
        }

        function placeSnakeFood() {
            snakeGame.food = {
                x: Math.floor(Math.random() * 15),
                y: Math.floor(Math.random() * 15)
            };
        }

        function updateSnake() {
            const head = {x: snakeGame.snake[0].x + snakeGame.dir.x, y: snakeGame.snake[0].y + snakeGame.dir.y};
            
            if(head.x < 0 || head.x >= 15 || head.y < 0 || head.y >= 15) {
                initSnakeGame(); 
                return;
            }
            
            for(let part of snakeGame.snake) {
                if(head.x === part.x && head.y === part.y) {
                    initSnakeGame(); return;
                }
            }

            snakeGame.snake.unshift(head);
            
            if(head.x === snakeGame.food.x && head.y === snakeGame.food.y) {
                snakeGame.score++;
                if(snakeGame.score >= 5) {
                    winMinigame();
                    return;
                }
                placeSnakeFood();
            } else {
                snakeGame.snake.pop();
            }
            
            drawSnake();
        }

        function drawSnake() {
            const cvs = document.getElementById('snake-canvas');
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,300,300);
            
            const s = 20; 
            ctx.fillStyle = 'red';
            ctx.fillRect(snakeGame.food.x*s, snakeGame.food.y*s, s, s);
            
            ctx.fillStyle = 'lime';
            for(let part of snakeGame.snake) {
                ctx.fillRect(part.x*s, part.y*s, s-1, s-1);
            }
            
            ctx.fillStyle = 'white';
            ctx.font = '20px monospace';
            ctx.fillText("Score: " + snakeGame.score + "/5", 10, 20);
        }

        // --- MINIGAME: PACMAN ---
        function initPacmanGame() {
            document.getElementById('math-screen').style.display = 'none';
            document.getElementById('pacman-screen').style.display = 'flex';
            gameState.activeMinigame = 'pacman';
            
            pacmanGame.grid = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,0,1,1,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,0,0,1,1,0,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,1,0,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];
            
            pacmanGame.pos = {x:1, y:1};
            pacmanGame.ghost = {x:8, y:8};
            pacmanGame.dir = {x:0, y:0};
            pacmanGame.nextDir = {x:0, y:0};
            pacmanGame.score = 0;
            pacmanGame.totalDots = 0;
            
            for(let y=0; y<10; y++) for(let x=0; x<10; x++) if(pacmanGame.grid[y][x] === 0) pacmanGame.totalDots++;
            
            if(pacmanGame.interval) clearInterval(pacmanGame.interval);
            pacmanGame.interval = setInterval(updatePacman, 200);
        }

        function updatePacman() {
            let nx = pacmanGame.pos.x + pacmanGame.nextDir.x;
            let ny = pacmanGame.pos.y + pacmanGame.nextDir.y;
            
            if(pacmanGame.grid[ny][nx] !== 1) {
                pacmanGame.dir = pacmanGame.nextDir;
            }
            
            nx = pacmanGame.pos.x + pacmanGame.dir.x;
            ny = pacmanGame.pos.y + pacmanGame.dir.y;
            
            if(pacmanGame.grid[ny][nx] !== 1) {
                pacmanGame.pos.x = nx;
                pacmanGame.pos.y = ny;
                
                if(pacmanGame.grid[ny][nx] === 0) {
                    pacmanGame.grid[ny][nx] = 2; 
                    pacmanGame.score++;
                    if(pacmanGame.score >= pacmanGame.totalDots) {
                        winMinigame();
                        return;
                    }
                }
            }
            
            pacmanGame.ghostTimer++;
            if(pacmanGame.ghostTimer % 2 === 0) {
                moveGhost();
            }
            
            if(pacmanGame.pos.x === pacmanGame.ghost.x && pacmanGame.pos.y === pacmanGame.ghost.y) {
                initPacmanGame(); 
                return;
            }
            
            drawPacman();
        }

        function moveGhost() {
            let moves = [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];
            let validMoves = moves.filter(m => pacmanGame.grid[pacmanGame.ghost.y + m.y][pacmanGame.ghost.x + m.x] !== 1);
            
            if(validMoves.length === 0) return;
            
            let chosenMove = validMoves[0];
            
            if(Math.random() < 0.7) {
                let minDst = 999;
                for(let m of validMoves) {
                    let dst = Math.abs((pacmanGame.ghost.x+m.x) - pacmanGame.pos.x) + Math.abs((pacmanGame.ghost.y+m.y) - pacmanGame.pos.y);
                    if(dst < minDst) {
                        minDst = dst;
                        chosenMove = m;
                    }
                }
            } else {
                chosenMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            }
            
            pacmanGame.ghost.x += chosenMove.x;
            pacmanGame.ghost.y += chosenMove.y;
        }

        function drawPacman() {
            const cvs = document.getElementById('pacman-canvas');
            const ctx = cvs.getContext('2d');
            const s = 30; 
            
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,300,300);
            
            for(let y=0; y<10; y++) {
                for(let x=0; x<10; x++) {
                    if(pacmanGame.grid[y][x] === 1) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x*s, y*s, s, s);
                    } else if(pacmanGame.grid[y][x] === 0) {
                        ctx.fillStyle = 'white';
                        ctx.beginPath(); ctx.arc(x*s + s/2, y*s + s/2, 4, 0, Math.PI*2); ctx.fill();
                    }
                }
            }
            
            ctx.fillStyle = 'yellow';
            ctx.beginPath(); ctx.arc(pacmanGame.pos.x*s + s/2, pacmanGame.pos.y*s + s/2, 10, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = 'red';
            ctx.fillRect(pacmanGame.ghost.x*s + 5, pacmanGame.ghost.y*s + 5, 20, 20);
        }

        // --- MINIGAME: MEMORY ---
        let memoryCards = [];
        let flippedCards = [];
        let matchesFound = 0;
        const memorySymbols = ['‚òÖ', '‚òÄ', '‚òÇ', '‚òÅ', '‚ö°', '‚ù§']; 

        function initMemoryGame() {
            document.getElementById('math-screen').style.display = 'none'; 
            document.getElementById('memory-screen').style.display = 'flex';
            
            const grid = document.getElementById('memory-grid');
            grid.innerHTML = '';
            memoryCards = [];
            flippedCards = [];
            matchesFound = 0;

            let deck = [...memorySymbols, ...memorySymbols];
            deck.sort(() => Math.random() - 0.5);

            deck.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'memory-card';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                card.onclick = () => flipCard(card);
                grid.appendChild(card);
            });
        }

        function flipCard(card) {
            if(flippedCards.length >= 2 || card.classList.contains('flipped') || card.classList.contains('matched')) return;

            card.classList.add('flipped');
            card.innerText = card.dataset.symbol;
            flippedCards.push(card);

            if(flippedCards.length === 2) {
                checkMatch();
            }
        }

        function checkMatch() {
            const [c1, c2] = flippedCards;
            if(c1.dataset.symbol === c2.dataset.symbol) {
                c1.classList.add('matched');
                c2.classList.add('matched');
                matchesFound++;
                flippedCards = [];
                if(matchesFound === 6) {
                    setTimeout(() => {
                        winMinigame();
                    }, 500);
                }
            } else {
                setTimeout(() => {
                    c1.classList.remove('flipped');
                    c1.innerText = "";
                    c2.classList.remove('flipped');
                    c2.innerText = "";
                    flippedCards = [];
                }, 1000);
            }
        }

        // --- C√ìDIGOS E FINALIZA√á√ÉO ---

        function revealCodeFragment() {
            if(gameState.codesFound.length < 4) {
                const index = gameState.codesFound.length;
                gameState.codesFound.push(gameState.finalCode[index]);
                updateCodeDisplay();
            }
        }

        function updateCodeDisplay() {
            let str = "C√≥digos: ";
            for(let i=0; i<4; i++) {
                if(i < gameState.codesFound.length) str += gameState.finalCode[i] + " ";
                else str += "_ ";
            }
            document.getElementById('code-collection').innerText = str;
        }

        function activateCrow() {
            timers.stalkerActiveTimer = GAME_CONFIG.stalkerDuration;
            showMessage("DARCI (O CORVO) CHEGOU!");
            const angle = Math.random() * Math.PI * 2;
            const radius = 30; 
            crowGroup.position.x = camera.position.x + Math.cos(angle) * radius;
            crowGroup.position.z = camera.position.z + Math.sin(angle) * radius;
            crowGroup.position.y = 2.0; 
            crowGroup.visible = true;
        }

        function updateCrowLogic(delta) {
            if (crowGroup.position.y < -10) return;

            crowGroup.lookAt(camera.position);

            const wingSpeed = 15;
            const wingAmp = 0.5;
            const wingAngle = Math.sin(performance.now() / 1000 * wingSpeed) * wingAmp;
            if(crowWings.length >= 2) {
                crowWings[0].rotation.z = -wingAngle;
                crowWings[1].rotation.z = wingAngle;
            }

            const dir = new THREE.Vector3().subVectors(camera.position, crowGroup.position).normalize();
            crowGroup.position.add(dir.multiplyScalar(GAME_CONFIG.stalkerSpeed * delta));

            const dist = crowGroup.position.distanceTo(camera.position);
            if (dist < 1.5) {
                if (!gameState.isHiding) {
                    takeDamage(1);
                    crowGroup.position.y = -50; 
                    timers.stalkerActiveTimer = 0; 
                    showMessage("Darci te bicou!");
                }
            }
        }

        function takeDamage(amount) {
            gameState.lives -= amount;
            updateHUD();
            if (gameState.lives <= 0) {
                triggerGameOver("Suas vidas acabaram.");
            } else {
                const overlay = document.getElementById('ui-layer');
                overlay.style.backgroundColor = 'rgba(255,0,0,0.5)';
                setTimeout(() => { 
                    overlay.style.backgroundColor = gameState.isHiding ? 'rgba(0,0,0,0.8)' : 'transparent'; 
                }, 200);
            }
        }

        function updateHUD() {
            let hearts = "";
            for(let i=0; i<gameState.lives; i++) hearts += "‚ù§";
            document.getElementById('lives-display').innerText = hearts;
        }

        function showMessage(text) {
            const el = document.getElementById('message-area');
            el.innerText = text;
            el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, 3000);
        }

        function triggerGameOver(reason) {
            gameState.gameOver = true;
            controls.unlock();
            document.getElementById('end-screen').style.display = 'flex';
            document.getElementById('end-title').innerText = "GAME OVER";
            document.getElementById('end-title').style.color = "red";
            document.getElementById('end-reason').innerText = reason;
            document.getElementById('btn-restart').style.display = 'block';
            document.getElementById('btn-next-day').style.display = 'none';
        }

        function triggerDayComplete() {
            gameState.gameOver = true; 
            controls.unlock();
            document.getElementById('end-screen').style.display = 'flex';
            document.getElementById('end-title').innerText = "DIA " + gameState.day + " COMPLETO!";
            document.getElementById('end-title').style.color = "cyan";
            document.getElementById('end-reason').innerText = "Voc√™ sobreviveu mais um dia.";
            
            document.getElementById('btn-restart').style.display = 'none';
            document.getElementById('btn-next-day').style.display = 'block';
            document.getElementById('btn-next-day').innerText = "INICIAR DIA " + (gameState.day + 1);
        }

        function triggerWinGame() {
            gameState.gameOver = true; 
            controls.unlock();
            document.getElementById('end-screen').style.display = 'flex';
            document.getElementById('end-title').innerText = "VIT√ìRIA SUPREMA!";
            document.getElementById('end-title').style.color = "lime";
            document.getElementById('end-reason').innerText = "Voc√™ sobreviveu aos 7 dias e derrotou o sistema escolar.";
            document.getElementById('btn-restart').style.display = 'block';
            document.getElementById('btn-restart').innerText = "JOGAR TUDO DE NOVO";
            document.getElementById('btn-next-day').style.display = 'none';
        }

        window.openDoorPanel = function() {
            if(gameState.codesFound.length < 4) {
                showMessage("Preciso dos 4 Cadernos/C√≥digos!");
                return;
            }
            gameState.inDoor = true;
            controls.unlock();
            document.getElementById('door-screen').style.display = 'flex';
            renderDoorPad();
        };

        window.closeDoorScreen = function() {
            document.getElementById('door-screen').style.display = 'none';
            gameState.inDoor = false;
            controls.lock();
        };

        let currentDoorInput = "";
        function renderDoorPad() {
            const pad = document.getElementById('door-pad');
            while(pad.children.length > 1) { pad.removeChild(pad.lastChild); }
            for(let i=1; i<=9; i++) createBtn(i);
            createBtn('C');
            createBtn(0);
            createBtn('OK');

            function createBtn(val) {
                const btn = document.createElement('button');
                btn.className = 'pad-btn';
                btn.innerText = val;
                btn.onclick = () => handlePadInput(val);
                pad.appendChild(btn);
            }
            updatePadDisplay();
        }

        function handlePadInput(val) {
            if(val === 'C') {
                currentDoorInput = "";
            } else if(val === 'OK') {
                checkDoorCode();
            } else {
                if(currentDoorInput.length < 4) currentDoorInput += val;
            }
            updatePadDisplay();
        }

        function updatePadDisplay() {
            document.getElementById('door-display').innerText = currentDoorInput.padEnd(4, '-');
        }

        function checkDoorCode() {
            const correct = gameState.finalCode.join('');
            if(currentDoorInput === correct) {
                currentDoorInput = "";
                closeDoorScreen();
                triggerDayComplete();
            } else {
                currentDoorInput = "";
                document.getElementById('door-display').innerText = "ERR";
                setTimeout(updatePadDisplay, 500);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameState.gameOver && !gameState.inDoor) return; 

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked && !gameState.isPaused && !gameState.gameOver) {
                
                // Helper vectors (define outside loop to avoid GC if possible, but inside is fine for clarity in this single file)
                const directionVector = new THREE.Vector3();
                const sideVector = new THREE.Vector3();
                
                camera.getWorldDirection(directionVector);
                directionVector.y = 0;
                directionVector.normalize();

                sideVector.copy(directionVector);
                sideVector.cross(camera.up);
                // sideVector is now pointing Right relative to camera look

                const oldPos = controls.getObject().position.clone();

                // Forward/Back
                if (moveForward) {
                    controls.getObject().position.addScaledVector(directionVector, GAME_CONFIG.walkSpeed * delta);
                }
                if (moveBackward) {
                    controls.getObject().position.addScaledVector(directionVector, -GAME_CONFIG.walkSpeed * delta);
                }

                // Left/Right
                if (moveRight) {
                    controls.getObject().position.addScaledVector(sideVector, GAME_CONFIG.walkSpeed * delta);
                }
                if (moveLeft) {
                    controls.getObject().position.addScaledVector(sideVector, -GAME_CONFIG.walkSpeed * delta);
                }

                const playerPos = controls.getObject().position;
                
                for(let wallBox of walls) {
                    if(wallBox.containsPoint(playerPos)) {
                        controls.getObject().position.copy(oldPos);
                    }
                }
                updateTemperature(delta);
                updateTimers(delta);
            }
            prevTime = time;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
        animate();

    </script>
</body>
</html>